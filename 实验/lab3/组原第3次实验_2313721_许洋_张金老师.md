# 组成原理实验课程第3次实验报告

实验名称：   lab2相关实验

学生姓名：许洋  学号：2313721  班级：张金老师  

### 一、实验目的

task1：寄存器堆仿真

task2：同步、异步RAM仿真、综合实现

task3：数字逻辑电路的设计与调试

### 二、实验内容说明

 l）寄存器堆仿真（参见3.4.l节，实践资源见lab2.zip）

2）同步、异步RAM仿真、综合实现（参见3.4.2节，实践资源见lab2.zip）

3）数字逻辑电路的设计与调试（参见3.43节，实践资源见lab2.zip）

### 三、实验步骤

task1和task2是分析性实验，没有具体的修改操作，按照要求导入文件生成IP信号即可，分析在下一节。

#### task3

###### 错误1

![20250402-165850](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-165850.jpg)

直接运行项目得到如上图所示，根据学习3.2.2节我发现num_csn，num_a_g均没有数值显示，显示波形为Z。

“Z”表示高阻，比如电路断路就会显示为高阻，这种错误往往是以下两个原因导致的: 1）RTL里声明为wire型的变量从未被赋值。 2）模块调用的信号未连接导致信号悬空。

“X”表示不定值，这种错误往往是以下两个原因之—导致的: 1）RTL里声明为reg型的变量从未被赋值。 2）RTL里多驱动的代码有时候也可能导致这种类型的错误。

我们进入tb.v文件进行查看，发现num_a_g，num_csn，led没有进行赋值，我们将其补充完整。得到下图。![20250402-163428.623-4](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-163428.623-4.jpg)

![20250402-163428.623-5](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-163428.623-5.jpg)

根据上图我们发现num_csn的值依旧为Z，经过上述判断我们继续查找和num_csn相关的地方，发现在模块调用过程中，名称错误，将num_csn错误的写成了num_scn，修改名称后可以正常显示波形数值。![20250402-163428.623-9](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-163428.623-9.jpg)

![20250402-171744](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-171744.jpg)

###### 错误2

我们发现num_a_g依旧是X，检查程序发现其没有被赋值，因为有一句话被注释掉了，所以我们需要解开注释，给num_a_g进行赋值。

```verilog
    show_data   <= ~switch;
```

![20250402-172217](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-172217.jpg)

解开注释之后我们发现，num_a_g出现了值但是下面的问题又出现了。

###### 错误3

如上图，我们发现图中时间卡住了，一直进行循环，所以我们需要检查循环错误![20250402-163428.623-7](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-163428.623-7.jpg)

这里由于两句话循环对keep_a_g和nxt_a_g进行赋值，造成循环，根据原理我们删除+nxt_a_g，

###### 错误4

我们继续往下看代码发现其中出现了越沿采样，我们需要将always语句中的=换成<=，将阻塞性赋值变为非阻塞性赋值![20250402-163428.623-1](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-163428.623-1.jpg)

###### 错误5

在波形图中我没有发现这个错误，然后进行了上箱实验如下图

<img src="D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-181733.573-1.jpg" alt="20250402-181733.573-1" style="zoom: 33%;" />

<img src="D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-181733.573-2.jpg" alt="20250402-181733.573-2" style="zoom:33%;" />

数字6不能正常显示，我们返回代码处进行查看，发现没有对6的情况进行判段，所以我们需要加上6的判断情况![20250402-163428.623-8](D:\许洋计算机科学与技术\计算机组成原理\实验\Vivado\lab2pic\20250402-163428.623-8.jpg)

加入之后继续验证实验没有问题。

### 四、实验结果分析

#### task1

波形图中经常出现的点：寄存器文件的存储单元通常在时钟上升沿更新。因此：在当前时钟周期，写操作将数据wdata写入地址waddr。如果读操作（rdata1）在同一时钟周期内发生，并且读地址与写地址相同，则读操作可以直接返回写入的数据。

##### Part0

我们观察第0部分的波形图进行分析发现，

初始状态 ：we = 0，表示不进行写操作。waddr = 5'd1，指定写地址为 1。wdata = 32'hffffffff，指定写入数据为全 1。raddr1 = 5'd1，读地址 1 指向地址 1。由于读地址没有被写入数据，所以rdata1读出来的值为XXXXXX（不确定值）。

第一次写入 ：在 #10 后，we 被置为 1'b1，开始写入操作。写入地址为 waddr = 5'd1，写入数据为 wdata = 32'h1111ffff。此时，raddr1 仍然指向地址 1，但由于写操作尚未完成，rdata1 显示为 XXXXXX（不确定值）。

读取操作：在下一个时间点，we 被置为 1'b0，停止写操作。raddr1 被更新为 5'd2，指向地址 2，由于地址2没有被写入数据，所以所以rdata1读出来的值为XXXXXX（不确定值）。raddr2 被更新为 5'd1，指向地址 1，读取出刚才写入的数据32'h1111ffff。

第二次读取 ：raddr1 被更新为 5'd1，再次指向地址 1。此时，rdata1 显示之前写入的数据 32'h1111ffff。![20250404-100732](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task1\20250404-100732.jpg)

##### Part1

我们观察第1部分的波形图进行分析发现，

连续写入：每次写入操作中，we 被置为 1'b1，指定不同的写地址和写数据。写入地址依次为 5'h10、5'h11、5'h12、5'h13、5'h14。写入数据依次为 32'h0000ffff、32'h1111ffff、32'h2222ffff、32'h3333ffff、32'h4444ffff。

读取操作 ：每次写入后，raddr1 和 raddr2 分别指向不同的地址。raddr1指向当前正在写入数据的地址，raddr2指向上一次写入数据的地址。例如，第一次写入后，raddr1 = 5'h10，raddr2 = 5'h0f；第二次写入后，raddr1 = 5'h11，raddr2 = 5'h10，依此类推。由于raddr1没有被写入数据，所以rdata1读出来的值为XXXXXX（不确定值）。raddr2写入数据，所以rdata2读出来的值为写入值。

![20250404-103027](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task1\20250404-103027.jpg)

##### Part2

我们观察第2部分的波形图进行分析发现，

读取操作：在此阶段，we 被置为 1'b1，但没有实际的写操作（因为没有新的 wdata 和 waddr 更新）。raddr1 和 raddr2 分别指向不同的地址，依次读取之前写入的数据。

读取数据验证：根据之前的写入操作，寄存器文件中存储了以下数据：地址 5'h10：32'h0000ffff，地址 5'h11：32'h1111ffff，地址 5'h12：32'h2222ffff，地址 5'h13：32'h3333ffff，地址 5'h14：32'h4444ffff。读取操作依次验证这些数据是否正确。![20250404-104003](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task1\20250404-104003.jpg)

#### task2

##### 同步RAM

###### Part0

初始状态 ：ram_wen = 0，表示不进行写操作，进行读操作。ram_addr = 16'hf0，指定地址为 0x00f0。ram_wdata = 32'hffffffff，指定写入数据为全 1。

第一次写入 ：在 #10 后，ram_wen 被置为 1'b1，开始写入操作。写入地址为 ram_addr = 16'hf0，写入数据为 ram_wdata = 32'h11223344。

读取操作 ：在下一个时间点，ram_wen 被置为 1'b0，停止写操作。ram_addr 被更新为 16'hf1，读取地址指向 0x00f1。但是没有时钟信号触发，读到的还是32'h11223344。时钟触发后读到00000000.接着，ram_addr 被更新为 16'hf0，再次指向地址 0x00f0。![20250404-104928](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task2_1\20250404-104928.jpg)

###### Part1

连续写入 ：每次写入操作中，ram_wen 被置为 1'b1，指定不同的地址和写入数据。写入地址依次为 16'hf0、16'hf1、16'hf2、16'hf3、16'hf4。写入数据依次为 32'hff00、32'hff11、32'hff22、32'hff33、32'hff44。![20250404-132217](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task2_1\20250404-132217.jpg)

###### Part2

读取操作 ：在此阶段，ram_wen 被置为 1'b0，表示不进行写操作。ram_addr 分别指向不同的地址，依次读取之前写入的数据。

读取数据验证 ：根据之前的写入操作，RAM 中存储了以下数据：地址 16'hf0：32'hff00，地址 16'hf1：32'hff11，地址 16'hf2：32'hff22，地址 16'hf3：32'hff33，地址 16'hf4：32'hff44。读取操作依次验证这些数据是否正确。![20250404-132952](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task2_1\20250404-132952.jpg)

##### 异步RAM

###### Part0

初始状态：ram_wen = 0，表示不进行写操作。ram_addr = 16'hf0，指定地址为 0x00f0。ram_wdata = 32'hffffffff，指定写入数据为全 1。

第一次写入 ：在 #10 后，ram_wen 被置为 1'b1，开始写入操作。写入地址为 ram_addr = 16'hf0，写入数据为 ram_wdata = 32'h11223344。

读取操作 ：在下一个时间点，ram_wen 被置为 1'b0，停止写操作。ram_addr 被更新为 16'hf1，读取地址指向 0x00f1。接着，ram_addr 被更新为 16'hf0，再次指向地址 0x00f0。![20250404-133310](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task2_2\20250404-133310.jpg)

###### Part1

连续写入 ：每次写入操作中，ram_wen 被置为1'b1，指定不同的地址和写入数据。写入地址依次为 16'hf0、16'hf1、16'hf2、16'hf3、16'hf4。写入数据依次为 32'hff00、32'hff11、32'hff22、32'hff33、32'hff44。![20250404-143757](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task2_2\20250404-143757.jpg)

###### Part2

读取操作 ：在此阶段，ram_wen 被置为 1'b0，表示不进行写操作。ram_addr 分别指向不同的地址，依次读取之前写入的数据。

读取数据验证 ：根据之前的写入操作，RAM 中存储了以下数据：地址 16'hf0：32'hff00，地址 16'hf1：32'hff11，地址 16'hf2：32'hff22，地址 16'hf3：32'hff33，地址 16'hf4：32'hff44。读取操作依次验证这些数据是否正确。![20250404-143904](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab3\task2_2\20250404-143904.jpg)

### 五、总结感想

#### 两读一写设计的原因：

寄存器堆通常设计为“两读一写”结构，主要原因如下：

指令执行需求：大多数指令需要从寄存器堆中读取两个操作数（源寄存器）并可能写入一个结果（目标寄存器）。

性能优化 ：允许同时进行两个读操作可以提高指令执行效率，减少流水线中的冲突。

硬件实现简单 ：相比于多读或多写的复杂结构，“两读一写”结构在硬件实现上更为简洁，成本更低。

#### 同步与异步 RAM 的特点和区别

##### 同步 RAM

特点 ：写入和读取操作都依赖时钟信号。数据更新发生在时钟上升沿或下降沿。具有更好的定时性和稳定性，适合高速应用。

在 Part 0 中，写入操作后需要等待时钟信号触发才能正确读取数据。在 Part 1 和 Part 2 中，连续写入和读取操作均依赖时钟信号，确保数据的同步更新。

##### 异步 RAM

特点 ：写入和读取操作不依赖时钟信号，直接根据控制信号（如 ram_wen）进行操作。响应速度快，但可能存在时序问题（如竞争条件）。成本较低，适合低速应用。

在 Part 0 中，写入操作后立即可以读取数据，无需等待时钟信号。在 Part 1 和 Part 2 中，连续写入和读取操作直接根据地址和控制信号完成，无需时钟同步。

##### 同步与异步 RAM 的对比

| 特性         | 同步 RAM               | 异步 RAM                       |
| ------------ | ---------------------- | ------------------------------ |
| **时钟依赖** | 依赖时钟信号           | 不依赖时钟信号                 |
| **数据更新** | 时钟上升沿或下降沿更新 | 控制信号变化时立即更新         |
| **稳定性**   | 更稳定，适合高速应用   | 可能存在时序问题，适合低速应用 |
| **成本**     | 相对较高               | 成本较低                       |

#### **总结感想**

1. 寄存器堆：寄存器堆的“两读一写”设计是为了满足指令执行的需求，同时简化硬件实现。

   ​					通过仿真验证了寄存器堆的读回机制，确保了写操作和读操作的正确性。

2. 同步与异步 RAM：同步 RAM 和异步 RAM 的主要区别在于是否依赖时钟信号。

   ​								同步 RAM 更适合高速应用，而异步 RAM 更适合低速应用。

   ​								通过仿真验证了两种 RAM 的基本功能，理解了它们各自的特点和应用场景。

3. 数字逻辑电路设计：设计和调试数字逻辑电路是一个系统化的过程，需要仔细检查代码中的每一个细节。

   ​									通过解决多个错误，掌握了 Verilog 编程中的常见问题及其解决方案。
