



# 组成原理实验课程第5次实验报告

实验名称：  单周期CPU和多周期CPU

学生姓名：许洋  学号：2313721  班级：张金老师  

### 一、实验目的

#### 单周期

1. 理解MIPS指令结构，理解MIPS指令集中常用指令的功能和编码，学会对这些 指令进行归纳分类。
2. 了解熟悉MIPS体系的处理器结构，如延迟槽，哈佛结构的概念。 
3. 熟悉并掌握单周期CPU的原理和设计。 
4. 进一步加强运用verilog语言进行电路设计的能力。 5. 为后续设计多周期cpu的实验打下基础。

#### 多周期

1. 在单周期CPU实验完成的提前下，理解多周期的概念。 
2. 熟悉并掌握多周期CPU的原理和设计。 
3. 进一步提升运用verilog语言进行电路设计的能力。
4. 为后续实现流水线cpu的课程设计打下基础

### 二、实验内容说明

请根据实验指导手册中的单周期CPU和多周期CPU实验内容，完成如下任务并撰写实验报告：

1、针对单周期CPU实验，复现并验证功能，同时对三种类型的MIPS指令，挑1~2条具体分析总结其执行过程。

2、针对多周期CPU实验，请认真分析指令ROM中的指令执行情况，找到存在的bug并修复，实验报告中总结寻找bug和修复bug的过程。

3、将ALU实验中扩展的三种运算，以自定义MIPS指令的形式，添加到多周期CPU实验代码中，并自行编写指令存储到指令ROM，然后验证正确性，波形验证或实验箱上箱验证均可。

### 三、实验原理图

#### 单周期CPU实现框图![20250510-151656](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\20250510-151656.jpg)

#### 多周期CPU实现框图![Page_1_docsmall.com](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\Page_1_docsmall.com.jpg)

### 四、实验步骤及分析

#### 单周期

##### 1. 指令

单周期CPU能够执行MIPS指令集系统的一个子集，共16条指令，包括存储访问指令、运算指令、跳转指令。根据拥有的字段类型不同，我们将指令分为 R 型指令、I 型指令和J 型指令。

* #### R 型指令

op 段（6b）：恒为0b000000；

rs（5b）、rt（5b） ：两个源操作数所在的寄存器号；

rd（5b）：目的操作数所在的寄存器号；

shamt（5位）：位移量，移位指令的移位位数；

func（6b）：决定 R 型指令的具体功能。

* #### I 型指令

op段（6b）：决定 I 型指令类型；

rs（5b）：是第一个源操作数所在的寄存器号；

rt （5b）：是第二个源操作数所在的寄存器号 或 目的操作数所在的寄存器编号。

constant or address（16b）：立即数或地址

* #### J 型指令

op段（6b）：决定 J 型指令类型；

constant or address（26b）：转移地址

##### 2. 不同指令的执行过程

* #### R 型指令

1. 从指令存储器中取指令，更新 PC 。
2. ALU 根据 funct 字段确定 ALU 的功能。
3. 从寄存器堆中读出寄存器 rs 和 rt。
4. ALU 根据 2 中确定的功能，对从寄存器堆读出的数据进行操作。
5. 将运算结果写入到 rd 字段对应的目标寄存器。

如图，第2条指令执行，逻辑左移。将寄存器$1的值左移4位，结果存入寄存器$2。$2 = 0000_0010H![20250510-170832](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\20250510-170832.jpg)

* #### I 型指令

* 存取指令：

1. 从指令存储器中取指令，更新 PC 。
2. ALU 根据 op 字段确定 ALU 的功能。
3. 从寄存器堆中读出寄存器 rs 的值，并将其与符号扩展后的指令低16位立即数的值相加。
4. 若为存储指令，则将 rt 寄存器中的值存到上步相加得到的存储器地址；
5. 若为取数指令，则将 上步所得存储器地址里所存的数据放到 rt 目标寄存器中。

如图，第1条指令执行，立即数加法（带符号）。将立即数1加到寄存器$0的值上，结果存入寄存器$1。$1 = 0000_0001H![20250510-170827](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\20250510-170827.jpg)

- 分支指令：

1. 从指令存储器中取指令，更新 PC 。
2. 从寄存器堆中读出寄存器 rs 和 rt 的值。
3. 将所读寄存器的两值相减。
4. 根据上步的结果是否为0，将 PC+4 的值或 address字段所对应地址存入PC中。

如图，第12条指令执行，相等跳转。如果寄存器$9和$1的值相等，则跳转到目标地址。跳转到指令34H![20250510-171150](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\20250510-171150.jpg)


* #### J 型指令

1. 从指令存储器中取指令，更新 PC 。
2. 取出 address 字段，作为目标跳转地址。
3. 将目标跳转地址存入PC中。

如图，最后一条指令执行，无条件跳转。跳转到地址00H。![20250510-170835](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\20250510-170835.jpg)

##### 3. bug

单周期的bug是位宽不同

```verilog
assign dm_wen   = {4{inst_SW}} & {4{resetn}};    // 内存写使能,非resetn状态下有效
```

#### 多周期

##### bug

ip核配置问题，我们进行自己配置ip核

<img src="D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\20250513-183955.428-1.jpg" alt="20250513-183955.428-1" style="zoom:50%;" />

<img src="D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\20250513-183955.428-2.jpg" alt="20250513-183955.428-2" style="zoom:50%;" />

##### 扩展运算

修改代码

我的修改过程是从熟悉的alu模块开始的，这次的修改和之前的不同，没有缩减控制位宽，而是为了方便直接扩展的位宽

```verilog
alu.v

input  [14:0] alu_control,  // ALU控制信号

assign alu_sgt  = alu_control[12];   //有符号比较，大于置位
assign alu_xnor = alu_control[13];  //按位同或
assign alu_hui  = alu_control[14];   //低位加载

//其他部分的修改和之前的一样
```

exe.v、decode.v和cpu.v都需要修改位宽

```verilog
exe.v

input      [152:0] ID_EXE_bus_r,// ID->EXE总线
//....
wire [14:0] alu_control;
```

```verilog
decode.v

output    [152:0]  ID_EXE_bus,  // ID->EXE总线
//....
wire [14:0] alu_control;
```

```verilog
cpu.v

wire [152:0] ID_EXE_bus;  // ID->EXE级总线
//....
reg [152:0] ID_EXE_bus_r;
```

decode.v中需要对定义的运算进行解码操作

```verilog
decode.v

// 实现指令列表
wire inst_SGT, inst_XNOR, inst_HUI;
//....
assign inst_SGT   = op_zero & sa_zero    & (funct == 6'b101100);
assign inst_XNOR  = op_zero & sa_zero    & (funct == 6'b101101);
assign inst_HUI   = (op == 6'b011111) & (rs==5'd0);
//....
//alu操作分类
wire inst_sgt, inst_xnor, inst_hui;
//...
assign inst_sgt =inst_SGT;
assign inst_xnor=inst_XNOR;
assign inst_hui =inst_HUI;
//....
//alu控制
assign alu_control = {
    inst_add, inst_sub,inst_slt,inst_sltu,inst_and,inst_nor,
    inst_or,inst_xor,inst_sll,inst_srl,inst_sra,inst_lui,
    inst_sgt,inst_xnor,inst_hui
};
```

coe文件修改以及机器码添加

在我修改的过程中，只在coe文件进行修改之后，并不能在mif文件中添加上机器码，我进行了手动添加。

```
coe文件添加三条指令
0232402C
0043202D
7C091234
```

```
mif文件添加三条机器码
00000010001100100100000000101100
00000000010000110010000000101101
01111100000010010001001000110100
```

仿真结果![20250510-174333](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\20250510-174333.jpg)

通过仿真我们可以看到成功的调用了三条指令，并且alu模块做出了反应，表明指令添加成功。

`sgt $t0, $s1, $s2 rs=17 ($s1), rt=18 ($s2), rd=8 ($t0)` 

 `xnor $a0, $v0, $v1 rs=2 ($v0), rt=3 ($v1), rd=4 ($a0)` 

`hui $t1, 0x1234 rt=9 ($t1), imm16=0x1234` 

这是三条指令进行上箱验证结果为

![微信图片_2025-05-12_222408_496](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\微信图片_2025-05-12_222408_496.jpg)

因为数字相同，所以t0为0

![微信图片_2025-05-12_222347_357](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\微信图片_2025-05-12_222347_357.jpg)

因为v0和v1不相同，所以a0置为0

![c0e7585bc50179c26df1d4299e5a5f09](D:\许洋计算机科学与技术\计算机组成原理\实验\实验\lab5\lab5pic\c0e7585bc50179c26df1d4299e5a5f09.jpg)

将t1进行加载数据为0x12340000

### 五、总结感想

本次实验让我系统掌握了单周期与多周期 CPU 的设计逻辑。在单周期 CPU 实验中，通过对 MIPS 指令集的拆解，我深入理解了 R 型、I 型、J 型指令的执行机制，并用 Verilog 实现了完整的指令流程。多周期 CPU 实验则聚焦于功能扩展，在修复指令 ROM 的 bug 过程中，我学会通过波形分析定位问题；将 ALU 扩展运算融入多周期 CPU 时，对多模块协同修改和指令存储机制有了更深刻的认知。

这次实践不仅强化了计算机组成原理的理论知识，更让我体会到硬件设计中全局思维与细节把控的重要性。调试过程中的反复试错、多模块代码的联动修改，都锤炼了我的问题解决能力。实验中暴露的知识盲区也促使我不断反思与查漏补缺，为后续流水线 CPU 的学习积累了宝贵经验，更激发了我对计算机硬件系统设计的探索兴趣。
