# 组成原理实验课程第2次实验报告

实验名称： 数据运算：定点乘法

学生姓名：许洋  学号：2313721  班级：张金老师  

### 一、实验目的

1. 理解定点乘法的不同实现算法的原理，掌握基本实现算法。 
2. 熟悉并运用 verilog 语言进行电路设计。 
3. 为后续设计 cpu 的实验打下基础。

### 二、实验内容说明

1. 学习并理解计算机中定点乘法器的多种实现算法的原理，重点掌握迭代乘法的 实现算法。
2. 自行设计本次实验的方案，画出结构框图，详细标出输入输出端口，本次实验 的乘法器建议采用迭代的方式实现，如果能力有余的，也可以采用其他效率更高的算 法实现。本次实验要求实现的乘法为有符号乘法，因此需要注意计算机存储的有符号 数都是补码的形式，设计方案传递进来的数也需是补码。
3. 根据设计的实验方案，使用 verilog 编写相应代码。 
4. 对编写的代码进行仿真，得到正确的波形图。
5. 将以上设计作为一个单独的模块，设计一个外围模块去调用该模块。外围模块中需调用封装好的 LCD 触摸屏模块，显示两个乘数和乘法结果，且需要 利用触摸功能输入两个乘数。
6. 将编写的代码进行综合布局布线，并下载到实验箱中的 FPGA 板子上进行演示。

### 三、实验原理图

![未命名文件](C:\Users\XY\Downloads\未命名文件.png)

### 四、实验步骤

##### 1.multiply.v模块的修改

###### 功能解释

实现了输入两个数，进行相乘的操作。对原来的代码进行了修改，将移动的乘数和输出的结果都从一位变成了两位，从而实现了时钟周期的缩短。

###### 代码解释与修改

 首先，修改了乘法模块中multplicand的模块，原本移动一位，现在变成了移动两位。原来的代码实现的是，将被乘数的前62位取出，再将最低位的一位设置成0，这样就完成了移动一位的操作。现在，修改为，取出被乘数的前61位，再将最后两位设置成0，这样我们就完成了左移两位的操作。

```verilog
	multiplicand <= {multiplicand[61:0],2'b00};
```

 原来是右移一位，那么现在修改为取出迭代前的第31位到第2位数，然后将最高位的两位设置成0，这样进行右移两位。

```verilog
	multiplier <= {2'b00,multiplier[31:2]}; 
```

  乘数向右移动两位的同时，我们需要考虑两位数字的可能出现的取值。在一位数字的时候，只有0和1两种情况，现在出现两位数字的时候，我们就需要考虑00/01/10/11这四种情况。由于上课所说case和if语句的问题，我们选择进行三目运算符的嵌套实现选择。

```verilog
	assign partial_product = (multiplier[1:0]==2'b00 ? 64'd0 : 
        (multiplier[1:0]==2'b01 ? multiplicand : 
        (multiplier[1:0]==2'b10 ? multiplicand<={multiplicand[62:0],1'b0} : 
        ( multiplier[1:0]==2'b11 ? multiplicand<={multiplicand[62:0],1'b0}+ multiplicand : 64'b0 ) ) ) );
    
```

为了减少修改，我们将每一次的结果都通过三目运算符进行运算，并且保存在了partial_product中。这种三目运算符的应用借助了上学期verilog课上的一个实验项目，当时也进行了嵌套实现。

 我们来做进一步的解释，其中当最低两位为00时，partial_product为0，即0倍的被乘数；当最低两位为01时，partial_product为1倍的被乘数；当最低两位为10时，partial_product为2倍的被乘数，通过左移一位来实现；当最低两位为11时，partial_product为3倍的被乘数，通过左移一位来实现并加上自身来实现，这里采用了<=，实现了运算后赋值。通过以上的分析，完成了对乘法器的修改。

##### 2.multiply_display.v模块修改

为了使触摸屏显示不在前四格，所以我们需要调整。将case进行改变。

```verilog
always @(posedge clk)
    begin
        case(display_number)
            6'd5 :
            begin
                display_valid <= 1'b1;
                display_name  <= "M_OP1";
                display_value <= mult_op1;
            end
            6'd6 :
            begin
                display_valid <= 1'b1;
                display_name  <= "M_OP2";
                display_value <= mult_op2;
            end
            6'd7 :
            begin
                display_valid <= 1'b1;
                display_name  <= "PRO_H";
                display_value <= product_r[63:32];
            end
            6'd8 :
            begin
                display_valid <= 1'b1;
                display_name  <= "PRO_L";
                display_value <= product_r[31: 0];
            end
            default :
            begin
                display_valid <= 1'b0;
                display_name  <= 48'd0;
                display_value <= 32'd0;
            end
        endcase
    end
```

##### 3.其他模块

 由于实验修改的是乘法器内部的语句，对于其他模块的功能没有需要修改的地方。

### 五、实验结果分析

##### 1.仿真验证

![image-20250320193107961](C:\Users\XY\AppData\Roaming\Typora\typora-user-images\image-20250320193107961.png)

 如上图所示，我们生成的两个随机数00000000000000000001000100010001，00000000000000000001000100010001，相乘后的结果为0000000000000000000000000000000000000001001000110100001100100001，所以说明我们的仿真结果是正确的。

##### 2.上箱验证

###### (1)正数乘正数

![image-20250326160748603](C:\Users\XY\AppData\Roaming\Typora\typora-user-images\image-20250326160748603.png)

 我们手动输入两个正数进行相乘，输入5和10，发现相乘得50，说明我们的结果是正确的。

###### (2)正数乘负数

![image-20250326160727994](C:\Users\XY\AppData\Roaming\Typora\typora-user-images\image-20250326160727994.png)

 我们输入一个正数和一个负数，输入1和-1，相乘得到结果-1，说明我们的结果是正确的。

###### (3)负数乘负数

![image-20250326160645302](C:\Users\XY\AppData\Roaming\Typora\typora-user-images\image-20250326160645302.png)

 我们输入两个负数进行相乘，输入两个-1（FFFFFFFF），输出结果1（00000001），证明了我们的结果是正确的。

##### 3.乘法器优化

通过上网检索，我发现乘法器可以进行优化。

###### (1)比较优化

1 初始化之际，取乘数和被乘数的正负关系，然后取乘数和被乘数的正值。

2 乘数和被乘数比较，如果被乘数小于乘数，则乘数和被乘数互换。

3 每一次累加操作，递减一次乘数，直到乘数的值为0，表示操作结束。

4 输出结果根据正负关系取得。

这样可以减少移动周期

```verilog
//multiplier_module_2.v
module multiplier_module_2
(
	input clk,
	input rst_n,
	input Start_Sig, 	//这是一个开始标志的寄存器
	
	input [7:0]Multiplicand,
	input [7:0]Multiplier,
	
	output Done_Sig,
	output [15:0]Product
);
 
	reg[2:0]i;
	reg[7:0]Mcand;		//乘数的数值部分（去掉符号）
	reg[7:0]Mer;		//被乘数的数值部分
	
	reg[15:0]Temp;		//乘积16位
	reg isNeg;
	reg isDone;
	
	always@(posedge clk or negedge rst_n)
		if(!rst_n)
			begin 
				i<=3'd0;
				Mcand<=8'd0;
				Mer<=8'd0;
				Temp<=16'd0;
				isNeg<=1'b0;
				isDone<=1'b0;
			end
		else if(Start_Sig)
			case(i)
				0:
				begin		//算出来符号，并且对乘数和被乘数都取整数准备计算
					isNeg<=Multiplicand[7]^Multiplier[7];
					Mcand<=Multiplicand[7]?(~Multiplicand+1'b1):Multiplicand;
					Mer<=Multiplier[7]?(~Multiplier+1'b1):Multiplier;
					Temp<=16'd0;
					i<=i+1'b1;
				end
				
				1:
				begin 		//比较乘数和被乘数的大小并交换位置
					{Mcand,Mer}<=Mcand<Mer?{Mer,Mcand}:{Mcand,Mer};  
					i<=i+1'b1;
				end
				
				2:		//交换后的乘数累加次数
				if(Mer==0)i<=i+1'b1;
				else begin Temp<=Temp+Mcand;Mer<=Mer-1'b1;end
				
				3:		//回0步骤
				begin isDone<=1'b1;i<=i+1'b1;end
				
				4:		//回0步骤
				begin isDone<=1'b0;i<=3'd0;end
				
			endcase
			
	assign Done_Sig=isDone;		//结束信号
	assign Product=isNeg?(~Temp+1'b1):Temp;		//如果乘积Temp是负数同样需要在原来的基础上进行取反后+！操作
emdmodule 
```

###### (2)Booth算法乘法器

```verilog
module booth_multiplier_module
(
	input clk, input rst_n,input Start_Sig, input[7:0]A, input [7:0]B,
	output [15:0]Product, output Done_Sig,
	output [7:0]SQ_a, output[7:0]SQ_s, output [16:0]SQ_p
);
	
	reg[3:0]i;
	reg[7:0]a;		//a寄存器用来寄存A值
	reg[7:0]s;		//s寄存器用来寄存-1（A）的值
	reg[16:0]p;
	reg[3:0]X;		//X表示n位，表示n次循环
	reg isDone;
	
	always@(posedge clk or negedge rst_n)
		if(!rst_n)
			begin 	
				i<=4'd0;
				a<=8'd0;
				s<=8'd0;
				s<=8'd0;
				p<=17'd0;
				X<=4'd0;
			end
		else if(Start_Sig)
			case(i)
				0:
				//初始化a,s的值，将P[8:1]位给B，其余位均为0
				begin a<=A;s<=(~A+1'b1);p<={8’d0,B,1'b0};i<=i+1'b1;end
				
				1:	//判断p[1:0]的操作
				if(X==8)begin X<=4'd0; i<=i+4'd2;end
				else if(p[1:0]==2'b01)begin p<={p[16:9]+a,p[8:0]};i<=i+1'b1;end
				else if(p[1:0]==2'b10)begin p<={p[16:9]+s,p[8:0]};i<=i+1'b1;end
				else i<=i+1'b1;
				
				2:	//向右移动1位是补0还是补1，完全取决于p[16]
				begin p<={p[16],p[16:1]};X<=X+1'b1;i<=i-1'b1;end
				
				3:
				begin isDone<=1'b1;i<=i+1'b1;end
				
				4:
				begin isDone<=1'b0;i<=4'd0;end
				
			endcase
	assign Done_Sig=isDone;
	assign product=p[16:1];
	
	assign SQ_a=a;
	assign SQ_s=S;
	assign SQ_p=p;
	
endmodule 
 
// Booth算法乘法器改进
module booth_multiplier_module_2
(
	input clk, input rst_n, input Start_Sig, input [7:0]A, input [7:0]B.
	output Done_Sig, output [15:0]Product, output [7:0]SQ_a, output [7:0]SQ_s, output [16:0]SQ_p	
);
 
	reg[3:0]i;
	reg[7:0]a;
	reg[7:0]s;
	reg[16:0]p;
	reg[7:0]Diff1;
	reg[7:0]Diff2;
	reg isDone;
	
	always@(posedge clk or negedge rst_n)
		if(!rst_n)
			begin 
				i<=4'd0;
				a<=8'd0;
				s<=8'd0;
				p<=17'd0;
				Diff1<=8'd0;
				Diff2<=8'd0;
				isDone<=1'b0;
			end
		else if(Start_Sig)
			case(i)
				0:
				begin 
					a<=A;
					s<=(~A+1'b1);
					p<={8'd0,B,1'b0};
					Diff<=8'd0;
					Diff<=8'd0;
					i<=i+1'b1;
				end
				1,2,3,4,5,6,7,8:    //8个循环操作使p空间的操作和移位可以在同一个时钟内完成
				begin	
					Diff1=p[16:9]+a;
					Diff2=p[16:9]+s;
					
					if(p[1:0]==2'b01)p<={Diff1[7],Diff1,p[8:1]};
					else if(p[1:0]==2'b10)p<={Diff2[7],Diff2,p[8:1]};
					else p<={p[16],p[16:1]};
					
					i<=i+1'b1;
				end
				9:
				begin isDone<=1'b1;i<=i+1'b1;end
				10:
				begin isDone<=1'b0;i<=4'd0;end
			endcase
	assign Done_Sig=isDone;
	assign Product=p[16:1];
	assign SQ_a=a;
	assign SQ_p=s;
	assign SQ_p=p;
endmodule
```

###### (3)其他方法

还有一些方法采用加法树，Wallace树和Dadda树

### 六、总结感想

1. 通过本次实验，我进一步掌握了vivado的使用以及 Verilog语句的编写，对数据的移位操作有了比较好的理解与应用，同时对乘法器的原理以及硬件实现有了 较好的掌握。
2. 对于时钟周期的优化，我们要考虑到移动位数的变化以及通过位数的改变能否影响到具体的时钟周期，我们通过将32个时钟周期长度进行一次性移动两位，实现了时钟周期的缩短，完成了优化。同样在这个过程中我们也了解了一些case和if的弊端，可以用三目运算符来解决。
3. 在对自己的优化进行了进一步研究，在网上学习了其他的优化方法以及原理。